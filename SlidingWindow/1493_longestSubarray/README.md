# 1493. 删掉一个元素以后全为 1 的最长子数组

给你一个二进制数组 nums ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

提示 1：

> 输入：nums = [1,1,0,1]
>
> 输出：3
>
> 解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。

示例 2：

> 输入：nums = [0,1,1,1,0,1,1,0,1]
>
> 输出：5
>
> 解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。

示例 3：

> 输入：nums = [1,1,1]
>
> 输出：2
>
> 解释：你必须要删除一个元素。

提示：

- 1 <= nums.length <= 105
- nums[i] 要么是 0 要么是 1 。

## 方法一

### 思路

删除一个元素，使其包含 1 最长的子数组

可以理解为找到一个连续的子数组，其中只有一个 0，剩下的全是 1 这样的最长子数组。

比如 [0,1,1,1,0,1,1,0,1] 中，[1,1,1,0,1,1] 中就只有一个 0，删除它后便是 1 最多的子数组。

### 代码

用 count 记录 1 出现的次数，flag 记录上一次 0 出现的下标

因为子数组中只能包含一个 0，因此当出现第二个 0 时就需要记录此时 count 的最大值。然后重制 count 为上一个 0 到此时的第二个 0 之间的 1 的个数。

比如[0,1,1,1,0,1,1,0,1]

当 i = 4 时，flag = 0 (第一个 0 的位置)，count = 3，此时 [0,1,1,1,0] 删除一个数最多有 3 个 1，更新 count = 4 - 0 - 1 = 3，flag = 4；
当 i = 7 时，flag = 4 (第二个 0 的位置)，count = 5，此时 [1,1,1,0,1,1,0] 删除一个数最多有 5 个 1，更新 count = 7 - 4 - 1 = 2，flag = 7；
当 i = 8 时，结束，count = 3，即子数组 [1,1,0,1] 中有 3 个 1，由于没有存在 0 再进行 num == 0 的判断，因此 count 累计 3 就是剩余子数组 1 的个数。

遍历结束之后，还需要处理两个特殊情况，当数组全部为 1 时，不会进入 num == 0 判断，因此删除一个数后 1 的个数为 count - 1；
如果数组只有一个 0，则 flag != -1，1 的个数即为 count 统计的数量。

```ts
function longestSubarray(nums: number[]): number {
  let count = 0;
  let res = 0;
  let flag = -1;

  for (let i = 0; i < nums.length; i++) {
    const num = nums[i];
    if (num == 1) count++;
    if (num == 0) {
      if (flag != -1) {
        res = Math.max(res, count);
        count = i - flag - 1;
      }
      flag = i;
    }
  }

  if (flag == -1) res = Math.max(res, count - 1);
  else res = Math.max(res, count);

  return res;
}
```
